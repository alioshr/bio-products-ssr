{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar mapProducts = function mapProducts(object) {\n  var array = [];\n\n  for (var key in object) {\n    array.push(_objectSpread({\n      id: key\n    }, object[key]));\n  }\n\n  return array;\n}; //used to transform nested objects chunks into arrays for mapping purposes\n\n\nexport var objChunkToArr = function objChunkToArr(object, key) {\n  var chunk = [];\n  Object.keys(object).some(function (k) {\n    if (k === key) {\n      for (var item in object[k]) {\n        chunk.push(_objectSpread({\n          id: item\n        }, object[k][item]));\n      }\n\n      object[k] = chunk;\n    }\n\n    if (object[k] && typeof object[k] === \"object\") {\n      objChunkToArr(object[k], key);\n    }\n\n    if (Array.isArray(object[k])) {\n      object[k].forEach(function (item) {\n        return objChunkToArr(item, key);\n      });\n    }\n  });\n  return object;\n}; //used to move one level up on the obj/array of objects tree \n//if you have the name of the ancestor and the full obj/arr of objects to loop in\n\nexport var findObjParent = function findObjParent(object, key) {\n  var parent = undefined;\n  Object.keys(object).some(function (k) {\n    if (k === key || object[k].id === key) {\n      return parent = object;\n    }\n\n    if (key !== k && object[k] && typeof object[k] === \"object\") {\n      parent = findObjParent(object[k], key);\n      return parent !== undefined;\n    }\n  });\n  return parent;\n}; //used to transform the first obj layer into an array\n\nexport var objToArray = function objToArray(obj) {\n  var sideDrawer = [];\n\n  for (var item in obj) {\n    sideDrawer.push(_objectSpread({\n      id: item\n    }, obj[item]));\n  }\n\n  return sideDrawer;\n}; //used to set state on my reducers\n\nexport var setState = function setState(state, newState) {\n  return _objectSpread(_objectSpread({}, state), newState);\n};","map":{"version":3,"sources":["/Users/Dev/Desktop/bio-products-ssr/Utilities/utilities.js"],"names":["mapProducts","object","array","key","push","id","objChunkToArr","chunk","Object","keys","some","k","item","Array","isArray","forEach","findObjParent","parent","undefined","objToArray","obj","sideDrawer","setState","state","newState"],"mappings":";;;;;;AAAA,IAAMA,WAAW,GAAG,SAAdA,WAAc,CAACC,MAAD,EAAY;AAC9B,MAAMC,KAAK,GAAG,EAAd;;AACA,OAAI,IAAIC,GAAR,IAAeF,MAAf,EAAuB;AACrBC,IAAAA,KAAK,CAACE,IAAN;AACMC,MAAAA,EAAE,EAAEF;AADV,OAESF,MAAM,CAACE,GAAD,CAFf;AAID;;AACD,SAAOD,KAAP;AACD,CATD,C,CAWA;;;AACA,OAAO,IAAMI,aAAa,GAAG,SAAhBA,aAAgB,CAACL,MAAD,EAASE,GAAT,EAAiB;AAC1C,MAAMI,KAAK,GAAG,EAAd;AACAC,EAAAA,MAAM,CAACC,IAAP,CAAYR,MAAZ,EAAoBS,IAApB,CAAyB,UAAUC,CAAV,EAAa;AACpC,QAAIA,CAAC,KAAKR,GAAV,EAAe;AACb,WAAK,IAAIS,IAAT,IAAiBX,MAAM,CAACU,CAAD,CAAvB,EAA4B;AAC1BJ,QAAAA,KAAK,CAACH,IAAN;AACEC,UAAAA,EAAE,EAAEO;AADN,WAEKX,MAAM,CAACU,CAAD,CAAN,CAAUC,IAAV,CAFL;AAID;;AACDX,MAAAA,MAAM,CAACU,CAAD,CAAN,GAAYJ,KAAZ;AACD;;AACD,QAAIN,MAAM,CAACU,CAAD,CAAN,IAAa,OAAOV,MAAM,CAACU,CAAD,CAAb,KAAqB,QAAtC,EAAgD;AAC9CL,MAAAA,aAAa,CAACL,MAAM,CAACU,CAAD,CAAP,EAAYR,GAAZ,CAAb;AACD;;AACD,QAAIU,KAAK,CAACC,OAAN,CAAcb,MAAM,CAACU,CAAD,CAApB,CAAJ,EAA8B;AAC5BV,MAAAA,MAAM,CAACU,CAAD,CAAN,CAAUI,OAAV,CAAkB,UAACH,IAAD;AAAA,eAAUN,aAAa,CAACM,IAAD,EAAOT,GAAP,CAAvB;AAAA,OAAlB;AACD;AACF,GAhBD;AAiBA,SAAOF,MAAP;AACD,CApBI,C,CAsBL;AACA;;AACA,OAAO,IAAMe,aAAa,GAAG,SAAhBA,aAAgB,CAACf,MAAD,EAASE,GAAT,EAAiB;AAC5C,MAAIc,MAAM,GAAGC,SAAb;AACAV,EAAAA,MAAM,CAACC,IAAP,CAAYR,MAAZ,EAAoBS,IAApB,CAAyB,UAACC,CAAD,EAAO;AAC9B,QAAIA,CAAC,KAAKR,GAAN,IAAaF,MAAM,CAACU,CAAD,CAAN,CAAUN,EAAV,KAAiBF,GAAlC,EAAuC;AACrC,aAAQc,MAAM,GAAGhB,MAAjB;AACD;;AACD,QAAIE,GAAG,KAAKQ,CAAR,IAAaV,MAAM,CAACU,CAAD,CAAnB,IAA0B,OAAOV,MAAM,CAACU,CAAD,CAAb,KAAqB,QAAnD,EAA6D;AAC3DM,MAAAA,MAAM,GAAGD,aAAa,CAACf,MAAM,CAACU,CAAD,CAAP,EAAYR,GAAZ,CAAtB;AACA,aAAOc,MAAM,KAAKC,SAAlB;AACD;AACF,GARD;AASA,SAAOD,MAAP;AACD,CAZM,C,CAcP;;AACA,OAAO,IAAME,UAAU,GAAG,SAAbA,UAAa,CAACC,GAAD,EAAS;AACjC,MAAMC,UAAU,GAAG,EAAnB;;AACA,OAAK,IAAIT,IAAT,IAAiBQ,GAAjB,EAAsB;AACpBC,IAAAA,UAAU,CAACjB,IAAX;AACEC,MAAAA,EAAE,EAAEO;AADN,OAEKQ,GAAG,CAACR,IAAD,CAFR;AAID;;AACD,SAAOS,UAAP;AACD,CATM,C,CAWP;;AACA,OAAO,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAACC,KAAD,EAAQC,QAAR,EAAqB;AAC3C,yCACKD,KADL,GAEKC,QAFL;AAID,CALM","sourcesContent":["const mapProducts = (object) => {\n  const array = [];\n  for(let key in object) {\n    array.push({\n          id: key,\n          ...object[key]\n      })\n  }\n  return array;\n}\n\n//used to transform nested objects chunks into arrays for mapping purposes\nexport const objChunkToArr = (object, key) => {\n    const chunk = [];\n    Object.keys(object).some(function (k) {\n      if (k === key) {\n        for (let item in object[k]) {\n          chunk.push({\n            id: item,\n            ...object[k][item],\n          });\n        }\n        object[k] = chunk;\n      }\n      if (object[k] && typeof object[k] === \"object\") {\n        objChunkToArr(object[k], key);\n      }\n      if (Array.isArray(object[k])) {\n        object[k].forEach((item) => objChunkToArr(item, key));\n      }\n    });\n    return object;\n  };\n  \n  //used to move one level up on the obj/array of objects tree \n  //if you have the name of the ancestor and the full obj/arr of objects to loop in\n  export const findObjParent = (object, key) => {\n    let parent = undefined;\n    Object.keys(object).some((k) => {\n      if (k === key || object[k].id === key) {\n        return (parent = object);\n      }\n      if (key !== k && object[k] && typeof object[k] === \"object\") {\n        parent = findObjParent(object[k], key);\n        return parent !== undefined;\n      }\n    });\n    return parent;\n  };\n  \n  //used to transform the first obj layer into an array\n  export const objToArray = (obj) => {\n    const sideDrawer = [];\n    for (let item in obj) {\n      sideDrawer.push({\n        id: item,\n        ...obj[item],\n      });\n    }\n    return sideDrawer;\n  };\n  \n  //used to set state on my reducers\n  export const setState = (state, newState) => {\n    return {\n      ...state,\n      ...newState,\n    };\n  };\n"]},"metadata":{},"sourceType":"module"}